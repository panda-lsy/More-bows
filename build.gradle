buildscript {
    repositories {
        mavenCentral()
        maven { url = "https://repo1.maven.org/maven2/" }
        maven { url = "https://maven.google.com/" }
        maven {
            name = "forge"
            url = "https://maven.minecraftforge.net/"
        }
        maven {
            name = "sonatype"
            url = "https://oss.sonatype.org/content/repositories/snapshots/"
        }
    }
    dependencies {
        dependencies {
            classpath group: 'net.minecraftforge.gradle', name: 'ForgeGradle', version: '5.1.+', changing: true
        }
        classpath 'com.guardsquare:proguard-gradle:7.2.2'
    }
}

plugins {
    id 'java-library'
    id 'maven-publish'
    id 'net.ltgt.errorprone' version '3.0.1'
    id 'com.github.spotbugs' version '5.0.13'
}

// Reproducible builds! https://docs.gradle.org/4.9/userguide/working_with_files.html#sec:reproducible_archives
tasks.withType(AbstractArchiveTask) {
    preserveFileTimestamps = false
    reproducibleFileOrder = true
}

apply plugin: 'java'
apply plugin: 'net.minecraftforge.gradle'

// TODO add compilation with Java toolchains

sourceCompatibility = 8
targetCompatibility = 8

final def compiler = javaToolchains.compilerFor {
    languageVersion = JavaLanguageVersion.of(8)
}

import groovy.json.JsonOutput
import groovy.json.JsonSlurper
import proguard.gradle.ProGuardTask

version = project.mod_version
group = project.mod_group

final def modName = project.mod_name
final def build_release = System.getenv("BUILD_RELEASE") == "true"

// Add snapshot suffix to version if not building a release.
// To build a release, set the environment variable BUILD_RELEASE to true.
if (!build_release) {
    version += "-SNAPSHOT"
}

// Information for ForgeGradle to configure the Minecraft / Forge version.
minecraft {
    mappings channel: project.mcp_channel, version: project.mcp_version
    // makeObfSourceJar = false // an Srg named sources jar is made by default. uncomment this to disable.

    // Default run configurations.
    runs {
        client {
            workingDirectory project.file('run')

            // Recommended logging data for a userdev environment
            property 'forge.logging.markers', 'SCAN,REGISTRIES,REGISTRYDUMP'

            // Recommended logging level for the console
            property 'forge.logging.console.level', 'debug'
        }

        server {
            workingDirectory project.file('run')

            // Recommended logging data for a userdev environment
            property 'forge.logging.markers', 'SCAN,REGISTRIES,REGISTRYDUMP'

            // Recommended logging level for the console
            property 'forge.logging.console.level', 'debug'
        }
    }
}

configurations {
    // Another list of dependencies to use with ProGaurd, as ForgeGradle isn't happy about resolving it the normal way.
    // I'm not happy about it either.
    proguardHack
}

// Include resources generated by data generators.
//sourceSets.main.resources { srcDir 'src/generated/resources' }

dependencies {
    minecraft "net.minecraftforge:forge:${project.forge_version}"

    // NullAway
    annotationProcessor "com.uber.nullaway:nullaway:0.10.3"

    // JetBrains null annotations
    compileOnly "org.jetbrains:annotations:23.0.0"
    proguardHack "org.jetbrains:annotations:23.0.0"

    // SpotBugs annotations
    compileOnly "com.github.spotbugs:spotbugs-annotations:4.7.3"
    proguardHack "com.github.spotbugs:spotbugs-annotations:4.7.3"

    // Error Prone
    errorprone "com.google.errorprone:error_prone_core:2.11.0"
    errorproneJavac "com.google.errorprone:javac:9+181-r4173-1"
}

jar.finalizedBy('reobfJar')

processResources {
    // This will ensure that this task is redone when the versions change.
    inputs.property "version", project.version
    inputs.property "minecraft_version", project.minecraft_version
    inputs.property "modName", project.mod_name

    // Replace values in only mcmod.info.
    filesMatching('mcmod.info') {
        expand 'version': version, 'modName': modName, 'mcversion': minecraft_version
    }

    // Validate and minify every JSON file.
    // Bonus super unnecessary micro-optimisation: mcmod.info and .mcmeta files are also JSON files!
    doLast {
        fileTree(dir: outputs.files.asPath, includes: [
            "**/mcmod.info",
            "**/*.mcmeta",
            "**/*.json"
        ]).each { final File file ->
            file.text = JsonOutput.toJson(new JsonSlurper().parse(file))
        }
    }
}

// Hack to add variables to source code on build. TODO: Remove this
task processSource(type: Sync) {
    // This will ensure that this task is redone when the versions change.
    inputs.property "version", project.version

    from('src/main/java') {
        filesMatching('iDiamondhunter/morebows/MoreBows.java') {
            expand 'version': version
        }
    }

    into "$buildDir/srcHack"
}

// Hack to add variables to source code on build. TODO: Remove this
compileJava {
    source = processSource.outputs
}

// workaround for userdev bug
tasks.create("copyResourceToClasses", Copy.class) {
    tasks.classes.dependsOn(it)
    dependsOn(tasks.processResources)
    onlyIf { gradle.taskGraph.hasTask(tasks.prepareRuns) }

    into("$buildDir/classes/java/main")
    // if you write @Mod class in kotlin, please use code below
    // into("$buildDir/classes/kotlin/main")
    from(tasks.processResources.destinationDir)
}

import net.ltgt.gradle.errorprone.CheckSeverity

tasks.withType(JavaCompile) {
    // Ensures that the encoding of source files is set to UTF-8, see http://yodaconditions.net/blog/fix-for-java-file-encoding-problems-with-gradle.html
    options.encoding = "UTF-8"
    // Tells Gradle to include more debug information in compiled .class files. For the optimised files, this will be removed by ProGuard.
    options.debug = true
    options.debugOptions.debugLevel = "source,lines,vars"

    // NullAway configuration
    options.errorprone {
        check("NullAway", CheckSeverity.ERROR)
        option("NullAway:AnnotatedPackages", "iDiamondhunter.morebows")
    }
}

// This task creates a .jar file containing the source code of this mod.
task sourcesJar(type: Jar, dependsOn: classes) {
    classifier = "sources"
    from sourceSets.main.allSource
}

// This task creates a .jar file containing a deobfuscated version of this mod, for ProGuard to minimise.
task unmappedJar(type: Jar) {
    classifier = "dev"
    from sourceSets.main.output
}

// This task uses ProGuard to shrink the built .jar's file size and optimise the bytecode. TODO Cleanup.
task proguard(dependsOn: unmappedJar, type: ProGuardTask) {
    verbose

    // Use the non-remapped .jar as the input file, because ForgeGradle has a convenient task to map it to obfuscated Minecraft class names for us when we're done optimising it
    injars "build/libs/" + rootProject.name + "-" + version + "-dev.jar"
    outjars "build/libs/" + rootProject.name + "-" + version + "-proguard-dev.jar"

    // Get the location of rt.jar from the provided toolchain.
    // Note to self: probably support building with not outdated versions of Java in the future.
    libraryjars compiler.get().metadata.installationPath.asFile.absolutePath + "/lib/rt.jar"
    // If rt.jar is not there, try looking inside a JRE folder instead.
    libraryjars compiler.get().metadata.installationPath.asFile.absolutePath + "/jre/lib/rt.jar"

    // Add relevant Minecraft libraries to ProGuard's list of libraries to obfuscate against.
    libraryjars project.configurations.minecraft

    // Add the dependencies to ProGuard's list of libraries to obfuscate against. I'd love a more sane way of doing this.
    libraryjars project.configurations.proguardHack

    // The rest of the configs are in this file
    configuration 'guard.pro'
}

// TODO rethink probably
task optimisedJar(type: Jar, dependsOn: proguard) {
    from zipTree(proguard.outputs.files.singleFile)
    //classifier = "proguard"
}

reobf {
    optimisedJar {
        // This line left intentionally blank?
    }
}

tasks.optimisedJar.finalizedBy('reobfOptimisedJar')

jar {
    classifier = "debug" // Contains things like variables with actual names, line numbers etc. Useful for debugging, but these things take up file size, so they have to go.
}

// Creates the listed artifacts on building the mod.
artifacts {
    archives sourcesJar
    archives optimisedJar
}

// TODO this is a bit dumb
task deleteProGuardOutput(type: Delete, dependsOn: proguard) {
    delete proguard.outputs.files.singleFile
}

build.finalizedBy(cleanUnmappedJar, deleteProGuardOutput)

publishing {
    publications {
        mavenJava(MavenPublication) {
            artifact(jar) {
                builtBy build
            }
            artifact(sourcesJar) {
                builtBy sourcesJar
            }
            artifact(optimisedJar) {
                builtBy optimisedJar
            }
        }
    }
}
